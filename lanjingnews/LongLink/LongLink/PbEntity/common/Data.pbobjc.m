// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/data.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Data.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - DataRoot

@implementation DataRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - DataRoot_FileDescriptor

static GPBFileDescriptor *DataRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"im.common"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum IMMessageType

GPBEnumDescriptor *IMMessageType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Text\000Image\000Audio\000";
    static const int32_t values[] = {
        IMMessageType_Text,
        IMMessageType_Image,
        IMMessageType_Audio,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(IMMessageType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:IMMessageType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL IMMessageType_IsValidValue(int32_t value__) {
  switch (value__) {
    case IMMessageType_Text:
    case IMMessageType_Image:
    case IMMessageType_Audio:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ChannelType

GPBEnumDescriptor *ChannelType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "MeetingMain\000MeetingDiscuss\000MettingTrans\000"
        "MettingStatus\000MettingRole\000MeetingQuit\000Ro"
        "llNews\000Push\000";
    static const int32_t values[] = {
        ChannelType_MeetingMain,
        ChannelType_MeetingDiscuss,
        ChannelType_MettingTrans,
        ChannelType_MettingStatus,
        ChannelType_MettingRole,
        ChannelType_MeetingQuit,
        ChannelType_RollNews,
        ChannelType_Push,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ChannelType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ChannelType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ChannelType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ChannelType_MeetingMain:
    case ChannelType_MeetingDiscuss:
    case ChannelType_MettingTrans:
    case ChannelType_MettingStatus:
    case ChannelType_MettingRole:
    case ChannelType_MeetingQuit:
    case ChannelType_RollNews:
    case ChannelType_Push:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - TextMeta

@implementation TextMeta

@dynamic hasContent, content;

typedef struct TextMeta__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
} TextMeta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = TextMeta_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TextMeta__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TextMeta class]
                                     rootClass:[DataRoot class]
                                          file:DataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TextMeta__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ImageMeta

@implementation ImageMeta

@dynamic hasURL, URL;
@dynamic hasHeight, height;
@dynamic hasWidth, width;

typedef struct ImageMeta__storage_ {
  uint32_t _has_storage_[1];
  int32_t height;
  int32_t width;
  NSString *URL;
} ImageMeta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ImageMeta_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ImageMeta__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = ImageMeta_FieldNumber_Height,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ImageMeta__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = ImageMeta_FieldNumber_Width,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ImageMeta__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ImageMeta class]
                                     rootClass:[DataRoot class]
                                          file:DataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ImageMeta__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AudioMeta

@implementation AudioMeta

@dynamic hasURL, URL;
@dynamic hasFormat, format;
@dynamic hasDuration, duration;

typedef struct AudioMeta__storage_ {
  uint32_t _has_storage_[1];
  int32_t duration;
  NSString *URL;
  NSString *format;
} AudioMeta__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = AudioMeta_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AudioMeta__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "format",
        .dataTypeSpecific.className = NULL,
        .number = AudioMeta_FieldNumber_Format,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AudioMeta__storage_, format),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "duration",
        .dataTypeSpecific.className = NULL,
        .number = AudioMeta_FieldNumber_Duration,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AudioMeta__storage_, duration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AudioMeta class]
                                     rootClass:[DataRoot class]
                                          file:DataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AudioMeta__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001!!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - User

@implementation User

@dynamic hasUid, uid;
@dynamic hasSname, sname;
@dynamic hasAvatar, avatar;
@dynamic hasRole, role;
@dynamic hasCompany, company;
@dynamic hasCompanyJob, companyJob;

typedef struct User__storage_ {
  uint32_t _has_storage_[1];
  int32_t uid;
  int32_t role;
  NSString *sname;
  NSString *avatar;
  NSString *company;
  NSString *companyJob;
} User__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(User__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sname",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_Sname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(User__storage_, sname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_Avatar,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(User__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "role",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_Role,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(User__storage_, role),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "company",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_Company,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(User__storage_, company),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "companyJob",
        .dataTypeSpecific.className = NULL,
        .number = User_FieldNumber_CompanyJob,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(User__storage_, companyJob),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[User class]
                                     rootClass:[DataRoot class]
                                          file:DataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(User__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IMMessage

@implementation IMMessage

@dynamic hasType, type;
@dynamic hasMessageId, messageId;
@dynamic hasFromUser, fromUser;
@dynamic hasText, text;
@dynamic hasImage, image;
@dynamic hasAudio, audio;
@dynamic hasIsQuestion, isQuestion;
@dynamic hasTimestamp, timestamp;
@dynamic hasMeetingId, meetingId;
@dynamic hasUuid, uuid;

typedef struct IMMessage__storage_ {
  uint32_t _has_storage_[1];
  IMMessageType type;
  int32_t timestamp;
  int32_t meetingId;
  User *fromUser;
  TextMeta *text;
  ImageMeta *image;
  AudioMeta *audio;
  NSString *uuid;
  int64_t messageId;
} IMMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = IMMessageType_Text,
        .core.name = "type",
        .core.dataTypeSpecific.enumDescFunc = IMMessageType_EnumDescriptor,
        .core.number = IMMessage_FieldNumber_Type,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(IMMessage__storage_, type),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueInt64 = 0LL,
        .core.name = "messageId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMessage_FieldNumber_MessageId,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(IMMessage__storage_, messageId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt64,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "fromUser",
        .core.dataTypeSpecific.className = GPBStringifySymbol(User),
        .core.number = IMMessage_FieldNumber_FromUser,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(IMMessage__storage_, fromUser),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "text",
        .core.dataTypeSpecific.className = GPBStringifySymbol(TextMeta),
        .core.number = IMMessage_FieldNumber_Text,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(IMMessage__storage_, text),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "image",
        .core.dataTypeSpecific.className = GPBStringifySymbol(ImageMeta),
        .core.number = IMMessage_FieldNumber_Image,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(IMMessage__storage_, image),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "audio",
        .core.dataTypeSpecific.className = GPBStringifySymbol(AudioMeta),
        .core.number = IMMessage_FieldNumber_Audio,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(IMMessage__storage_, audio),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "isQuestion",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMessage_FieldNumber_IsQuestion,
        .core.hasIndex = 6,
        .core.offset = 7,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "timestamp",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMessage_FieldNumber_Timestamp,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(IMMessage__storage_, timestamp),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "meetingId",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMessage_FieldNumber_MeetingId,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(IMMessage__storage_, meetingId),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "uuid",
        .core.dataTypeSpecific.className = NULL,
        .core.number = IMMessage_FieldNumber_Uuid,
        .core.hasIndex = 10,
        .core.offset = (uint32_t)offsetof(IMMessage__storage_, uuid),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IMMessage class]
                                     rootClass:[DataRoot class]
                                          file:DataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(IMMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PlainTextMessage

@implementation PlainTextMessage

@dynamic hasText, text;
@dynamic hasRelationMessageId, relationMessageId;
@dynamic hasTimestamp, timestamp;
@dynamic hasMeetingId, meetingId;

typedef struct PlainTextMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t relationMessageId;
  int32_t timestamp;
  int32_t meetingId;
  TextMeta *text;
} PlainTextMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.className = GPBStringifySymbol(TextMeta),
        .number = PlainTextMessage_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PlainTextMessage__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "relationMessageId",
        .dataTypeSpecific.className = NULL,
        .number = PlainTextMessage_FieldNumber_RelationMessageId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PlainTextMessage__storage_, relationMessageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = PlainTextMessage_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PlainTextMessage__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "meetingId",
        .dataTypeSpecific.className = NULL,
        .number = PlainTextMessage_FieldNumber_MeetingId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PlainTextMessage__storage_, meetingId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PlainTextMessage class]
                                     rootClass:[DataRoot class]
                                          file:DataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PlainTextMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StatusMessage

@implementation StatusMessage

@dynamic hasUser, user;
@dynamic hasMeetingId, meetingId;
@dynamic hasStatus, status;
@dynamic hasOnlineCount, onlineCount;

typedef struct StatusMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t meetingId;
  int32_t status;
  int32_t onlineCount;
  User *user;
} StatusMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = StatusMessage_FieldNumber_User,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StatusMessage__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meetingId",
        .dataTypeSpecific.className = NULL,
        .number = StatusMessage_FieldNumber_MeetingId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StatusMessage__storage_, meetingId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = StatusMessage_FieldNumber_Status,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(StatusMessage__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "onlineCount",
        .dataTypeSpecific.className = NULL,
        .number = StatusMessage_FieldNumber_OnlineCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(StatusMessage__storage_, onlineCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StatusMessage class]
                                     rootClass:[DataRoot class]
                                          file:DataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StatusMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RoleChangeMessage

@implementation RoleChangeMessage

@dynamic hasUser, user;
@dynamic hasMeetingId, meetingId;

typedef struct RoleChangeMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t meetingId;
  User *user;
} RoleChangeMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = RoleChangeMessage_FieldNumber_User,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RoleChangeMessage__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meetingId",
        .dataTypeSpecific.className = NULL,
        .number = RoleChangeMessage_FieldNumber_MeetingId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RoleChangeMessage__storage_, meetingId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RoleChangeMessage class]
                                     rootClass:[DataRoot class]
                                          file:DataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RoleChangeMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QuitMessage

@implementation QuitMessage

@dynamic hasUser, user;
@dynamic hasMeetingId, meetingId;
@dynamic hasType, type;
@dynamic hasReason, reason;

typedef struct QuitMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t meetingId;
  int32_t type;
  User *user;
  NSString *reason;
} QuitMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "user",
        .dataTypeSpecific.className = GPBStringifySymbol(User),
        .number = QuitMessage_FieldNumber_User,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QuitMessage__storage_, user),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meetingId",
        .dataTypeSpecific.className = NULL,
        .number = QuitMessage_FieldNumber_MeetingId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QuitMessage__storage_, meetingId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = QuitMessage_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(QuitMessage__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "reason",
        .dataTypeSpecific.className = NULL,
        .number = QuitMessage_FieldNumber_Reason,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(QuitMessage__storage_, reason),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QuitMessage class]
                                     rootClass:[DataRoot class]
                                          file:DataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QuitMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RollNewsMessage

@implementation RollNewsMessage

@dynamic hasId_p, id_p;
@dynamic hasTimestamp, timestamp;
@dynamic hasContent, content;
@dynamic hasType, type;

typedef struct RollNewsMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t id_p;
  int32_t timestamp;
  int32_t type;
  NSString *content;
} RollNewsMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = RollNewsMessage_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RollNewsMessage__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = RollNewsMessage_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RollNewsMessage__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = RollNewsMessage_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RollNewsMessage__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = RollNewsMessage_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RollNewsMessage__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RollNewsMessage class]
                                     rootClass:[DataRoot class]
                                          file:DataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RollNewsMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushExtra

@implementation PushExtra

@dynamic hasPushType, pushType;
@dynamic hasJump, jump;

typedef struct PushExtra__storage_ {
  uint32_t _has_storage_[1];
  int32_t pushType;
  NSString *jump;
} PushExtra__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pushType",
        .dataTypeSpecific.className = NULL,
        .number = PushExtra_FieldNumber_PushType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushExtra__storage_, pushType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "jump",
        .dataTypeSpecific.className = NULL,
        .number = PushExtra_FieldNumber_Jump,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushExtra__storage_, jump),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushExtra class]
                                     rootClass:[DataRoot class]
                                          file:DataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushExtra__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushMessage

@implementation PushMessage

@dynamic hasTitle, title;
@dynamic hasContent, content;
@dynamic hasExtra, extra;

typedef struct PushMessage__storage_ {
  uint32_t _has_storage_[1];
  NSString *title;
  NSString *content;
  PushExtra *extra;
} PushMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "title",
        .dataTypeSpecific.className = NULL,
        .number = PushMessage_FieldNumber_Title,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushMessage__storage_, title),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PushMessage_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushMessage__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extra",
        .dataTypeSpecific.className = GPBStringifySymbol(PushExtra),
        .number = PushMessage_FieldNumber_Extra,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PushMessage__storage_, extra),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushMessage class]
                                     rootClass:[DataRoot class]
                                          file:DataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NotifyMessage

@implementation NotifyMessage

@dynamic hasChannelType, channelType;
@dynamic hasData_p, data_p;

typedef struct NotifyMessage__storage_ {
  uint32_t _has_storage_[1];
  ChannelType channelType;
  NSData *data_p;
} NotifyMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = ChannelType_MeetingMain,
        .core.name = "channelType",
        .core.dataTypeSpecific.enumDescFunc = ChannelType_EnumDescriptor,
        .core.number = NotifyMessage_FieldNumber_ChannelType,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(NotifyMessage__storage_, channelType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueData = nil,
        .core.name = "data_p",
        .core.dataTypeSpecific.className = NULL,
        .core.number = NotifyMessage_FieldNumber_Data_p,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(NotifyMessage__storage_, data_p),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NotifyMessage class]
                                     rootClass:[DataRoot class]
                                          file:DataRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(NotifyMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
